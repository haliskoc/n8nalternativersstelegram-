#!/bin/bash

# Detect OS
OS="$(uname -s)"
case "${OS}" in
    Linux*)     OS_TYPE=Linux;;
    Darwin*)    OS_TYPE=Mac;;
    CYGWIN*|MINGW*|MSYS*) OS_TYPE=Windows;;
    *)          OS_TYPE="UNKNOWN";;
esac

# Define sed command based on OS
if [[ "$OS_TYPE" == "Mac" ]]; then
    SED_CMD="sed -i ''"
else
    SED_CMD="sed -i"
fi

# Check for root privileges (Only strict on Linux)
if [[ "$OS_TYPE" == "Linux" && $EUID -ne 0 ]]; then
   echo -e "\033[0;31mBu script sudo (root) yetkisi ile çalıştırılmalıdır.\033[0m"
   echo -e "\033[0;31mThis script must be run with sudo (root) privileges.\033[0m"
   echo "Örn: sudo ./setup.sh"
   exit 1
fi

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# RSS Feeds are now loaded dynamically from feeds_db.txt
# Generated by generate_feeds_db.py


# Language Selection
echo -e "${BLUE}Select Language / Dil Seçiniz:${NC}"
echo "1) English"
echo "2) Türkçe"
echo "3) Español"
echo "4) Русский"
echo "5) Português"
read -p "Choice/Seçim (1-5): " lang_choice

case "$lang_choice" in
    2) export LANG_CODE="tr" ;;
    3) export LANG_CODE="es" ;;
    4) export LANG_CODE="ru" ;;
    5) export LANG_CODE="pt" ;;
    *) export LANG_CODE="en" ;;
esac

# Load messages from JSON using Python
if command -v python3 &> /dev/null; then
    # Create a temporary file to store the variables
    # Use shlex.quote for safe shell escaping
    python3 -c "
import json
import os
import shlex

try:
    with open('locales.json', 'r', encoding='utf-8') as f:
        data = json.load(f)
        
    lang_code = os.environ.get('LANG_CODE', 'en')
    msgs = data.get(lang_code, data['en'])['messages']
    
    with open('lang_vars.tmp', 'w', encoding='utf-8') as f:
        for k, v in msgs.items():
            # shlex.quote handles all escaping safely for posix shells
            f.write(f\"{k}={shlex.quote(v)}\\n\")
            
except Exception as e:
    print(f\"Error loading language: {e}\")
"
    
    if [ -f lang_vars.tmp ]; then
        source lang_vars.tmp
        rm lang_vars.tmp
    else
        echo "Error: Could not load language variables."
    fi
else
    echo "Python3 not found. Defaulting to English."
    # Fallback defaults
    MSG_HEADER="RSS Telegram Bot - Auto Setup Script"
    MSG_DOCKER_CHECK="Checking Docker..."
    MSG_DOCKER_MISSING="Docker not found!"
    MSG_DOCKER_INSTALL_PREFIX="To install:"
    MSG_DOCKER_OK="Docker is installed."
    MSG_COMPOSE_MISSING="Docker Compose not found!"
    MSG_COMPOSE_OK="Docker Compose is installed."
    MSG_CONFIG="Configuring..."
    MSG_ENV_EXISTS=".env file already exists."
    MSG_RECREATE="Recreate? (y/n): "
    MSG_USING_EXISTING="Using existing config."
    MSG_ENTER_INFO="Enter details:"
    MSG_STEP_TOKEN="Enter Token:"
    MSG_STEP_CHATID="Enter Chat ID:"
    MSG_STEP_AI="AI Settings:"
    MSG_STEP_FEEDS="RSS Feeds:"
    MSG_FEEDS_INTRO="Select feeds:"
    MSG_FEEDS_INSTRUCT="Toggle with number:"
    MSG_FEEDS_ALL="Select all 'a':"
    MSG_FEEDS_SAVED="Saved."
    MSG_FEEDS_NONE="None selected."
    MSG_FEEDS_RECREATE="Reconfigure? (y/n): "
    MSG_TOKEN_EMPTY="Token empty!"
    MSG_CHATID_EMPTY="Chat ID empty!"
    MSG_AI_KEY_PROMPT="Key: "
    MSG_AI_MODEL_PROMPT="Model: "
    MSG_ENV_CREATED=".env created."
    MSG_STARTING="Starting..."
    MSG_CLEANING="Cleaning..."
    MSG_DONE_HEADER="Done!"
    MSG_DONE_SUCCESS="Running."
    MSG_LOGS="Logs: "
    MSG_ERROR="Error!"
fi

# Handle Dynamic Docker Install Message based on OS
if [[ "$OS_TYPE" == "Mac" ]]; then
    MSG_DOCKER_INSTALL="$MSG_DOCKER_INSTALL_PREFIX https://docs.docker.com/desktop/install/mac-install/"
elif [[ "$OS_TYPE" == "Windows" ]]; then
    MSG_DOCKER_INSTALL="$MSG_DOCKER_INSTALL_PREFIX https://docs.docker.com/desktop/install/windows-install/"
else
    # Detect Linux Distro
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=$NAME
    else
        DISTRO="Linux"
    fi
    
    case "$DISTRO" in
        *"Ubuntu"*|*"Debian"*|*"Mint"*)
            MSG_DOCKER_INSTALL="$MSG_DOCKER_INSTALL_PREFIX curl -fsSL https://get.docker.com | sh"
            ;;
        *"Fedora"*|*"CentOS"*|*"RHEL"*)
            MSG_DOCKER_INSTALL="$MSG_DOCKER_INSTALL_PREFIX sudo dnf install docker-ce docker-ce-cli containerd.io"
            ;;
        *"Arch"*|*"Manjaro"*)
            MSG_DOCKER_INSTALL="$MSG_DOCKER_INSTALL_PREFIX sudo pacman -S docker"
            ;;
        *)
            MSG_DOCKER_INSTALL="$MSG_DOCKER_INSTALL_PREFIX curl -fsSL https://get.docker.com | sh"
            ;;
    esac
fi

echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}${MSG_HEADER}${NC}"
echo -e "${BLUE}================================================${NC}"

# 1. Docker Check
echo -e "\n${BLUE}${MSG_DOCKER_CHECK}${NC}"
if ! command -v docker &> /dev/null; then
    echo -e "${RED}${MSG_DOCKER_MISSING}${NC}"
    
    if [[ "$OS_TYPE" == "Linux" ]]; then
        echo "Docker otomatik yükleniyor... / Installing Docker automatically..."
        
        # Detect Distro again if needed or use the one detected earlier
        if [ -f /etc/os-release ]; then
            . /etc/os-release
            DISTRO=$NAME
        fi
        
        case "$DISTRO" in
            *"Ubuntu"*|*"Debian"*|*"Mint"*)
                curl -fsSL https://get.docker.com | sh
                ;;
            *"Fedora"*|*"CentOS"*|*"RHEL"*)
                if command -v dnf &> /dev/null; then
                    dnf install -y dnf-plugins-core
                    dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
                    dnf install -y docker-ce docker-ce-cli containerd.io
                    systemctl start docker
                    systemctl enable docker
                else
                     curl -fsSL https://get.docker.com | sh
                fi
                ;;
            *"Arch"*|*"Manjaro"*)
                pacman -Sy --noconfirm docker
                systemctl start docker
                systemctl enable docker
                ;;
            *)
                curl -fsSL https://get.docker.com | sh
                ;;
        esac
        
        # Check again
        if ! command -v docker &> /dev/null; then
             echo "Docker kurulumu başarısız oldu. Lütfen manuel kurun."
             exit 1
        fi
        echo "Docker başarıyla kuruldu."
    else
        echo "$MSG_DOCKER_INSTALL"
        exit 1
    fi
fi
echo -e "${GREEN}${MSG_DOCKER_OK}${NC}"

# 2. Docker Compose Check
if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
    echo -e "${RED}${MSG_COMPOSE_MISSING}${NC}"
    exit 1
fi
echo -e "${GREEN}${MSG_COMPOSE_OK}${NC}"

# 3. Configuration
echo -e "\n${BLUE}${MSG_CONFIG}${NC}"

if [ -f .env ]; then
    echo -e "${GREEN}${MSG_ENV_EXISTS}${NC}"
    read -p "$MSG_RECREATE" recreate
    if [[ $recreate != "e" && $recreate != "y" ]]; then
        echo "$MSG_USING_EXISTING"
    else
        rm .env
    fi
fi

if [ ! -f .env ]; then
    echo -e "${GREEN}${MSG_ENTER_INFO}${NC}"
    
    echo -e "\n${BLUE}${MSG_STEP_TOKEN}${NC}"
    read -p "Telegram Bot Token: " raw_token
    while [[ -z "$raw_token" ]]; do
        echo -e "${RED}${MSG_TOKEN_EMPTY}${NC}"
        read -p "Telegram Bot Token: " raw_token
    done

    # Extract token if user pasted the whole message
    token=$(echo "$raw_token" | grep -oE "[0-9]+:[a-zA-Z0-9_-]+")
    if [[ -z "$token" ]]; then
        token="$raw_token"
    fi

    echo -e "\n${BLUE}${MSG_STEP_CHATID}${NC}"
    read -p "Chat ID: " chat_id
    while [[ -z "$chat_id" ]]; do
        echo -e "${RED}${MSG_CHATID_EMPTY}${NC}"
        read -p "Chat ID: " chat_id
    done

    echo -e "\n${BLUE}${MSG_STEP_AI}${NC}"
    read -p "$MSG_AI_KEY_PROMPT" openrouter_key
    
    if [[ -n "$openrouter_key" ]]; then
        read -p "$MSG_AI_MODEL_PROMPT" openrouter_model
        if [[ -z "$openrouter_model" ]]; then
            openrouter_model="google/gemini-2.0-flash-lite-preview-02-05:free"
        fi
    else
        openrouter_model=""
    fi

    # Create .env file
    echo "TELEGRAM_TOKEN=\"$token\"" > .env
    echo "CHAT_ID=\"$chat_id\"" >> .env
    echo "OPENROUTER_API_KEY=\"$openrouter_key\"" >> .env
    echo "OPENROUTER_MODEL=\"$openrouter_model\"" >> .env
    
    echo -e "${GREEN}${MSG_ENV_CREATED}${NC}"
fi

# 4. RSS Feed Selection
echo -e "\n${BLUE}${MSG_STEP_FEEDS}${NC}"

# Generate DB if needed
if [ ! -f feeds_db.txt ]; then
    echo "Generating feed database..."
    python3 generate_feeds_db.py
fi

configure_feeds=true
if [ -f feeds.json ]; then
    read -p "$MSG_FEEDS_RECREATE" recreate_feeds
    if [[ $recreate_feeds != "e" && $recreate_feeds != "y" ]]; then
        configure_feeds=false
    fi
fi

if [ "$configure_feeds" = true ]; then
    # Temporary file for selected line numbers
    > selected_lines.txt
    
    # Load existing feeds if they exist
    if [ -f feeds.json ]; then
        echo "Loading existing feeds..."
        python3 -c "
import json
import os
try:
    if os.path.exists('feeds.json') and os.path.exists('feeds_db.txt'):
        with open('feeds.json', 'r') as f:
            urls = json.load(f)
        with open('feeds_db.txt', 'r') as f:
            db_lines = f.readlines()
        selected = []
        for i, line in enumerate(db_lines, 1):
            parts = line.strip().split('|')
            if len(parts) >= 3 and parts[2] in urls:
                selected.append(str(i))
        if selected:
            with open('selected_lines.txt', 'w') as f:
                f.write('\n'.join(selected) + '\n')
except:
    pass
"
    fi
    
    while true; do
        clear
        echo -e "${BLUE}=== RSS FEED MANAGER ===${NC}"
        echo "1) Search Feeds / Haber Kaynağı Ara"
        echo "2) Browse by Category / Kategorilere Göre Gez"
        echo "3) View Selected / Seçilenleri Gör"
        echo "4) Save & Exit / Kaydet ve Çık"
        echo "------------------------------------------------"
        read -p "Choice/Seçim: " menu_choice
        
        case $menu_choice in
            1)
                read -p "Search Query/Arama Terimi: " query
                if [[ -n "$query" ]]; then
                    echo -e "${BLUE}Results for '$query':${NC}"
                    # Grep with line numbers, case insensitive
                    grep -in "$query" feeds_db.txt > search_results.tmp
                    
                    # Display loop
                    while true; do
                        # Read search results and display with selection status
                        i=1
                        declare -a map_lines
                        while IFS= read -r line; do
                            line_num=$(echo "$line" | cut -d: -f1)
                            content=$(echo "$line" | cut -d: -f2-)
                            cat_name=$(echo "$content" | cut -d'|' -f1)
                            feed_name=$(echo "$content" | cut -d'|' -f2)
                            
                            if grep -q "^$line_num$" selected_lines.txt; then
                                mark="[x]"
                                color=$GREEN
                            else
                                mark="[ ]"
                                color=$NC
                            fi
                            
                            printf "${color}%3d. %s %s (%s)${NC}\n" $i "$mark" "$feed_name" "$cat_name"
                            map_lines[$i]=$line_num
                            ((i++))
                        done < search_results.tmp
                        
                        if [[ $i -eq 1 ]]; then
                            echo "No results found."
                            break
                        fi
                        
                        echo "------------------------------------------------"
                        read -p "Toggle # (0 to back): " toggle_idx
                        
                        if [[ "$toggle_idx" == "0" || -z "$toggle_idx" ]]; then
                            break
                        elif [[ -n "${map_lines[$toggle_idx]}" ]]; then
                            lnum=${map_lines[$toggle_idx]}
                            if grep -q "^$lnum$" selected_lines.txt; then
                                $SED_CMD "/^$lnum$/d" selected_lines.txt
                            else
                                echo "$lnum" >> selected_lines.txt
                            fi
                        fi
                        clear
                        echo -e "${BLUE}Results for '$query':${NC}"
                    done
                    rm search_results.tmp
                fi
                ;;
            2)
                # Get categories
                cut -d'|' -f1 feeds_db.txt | sort | uniq > categories.tmp
                
                while true; do
                    clear
                    echo -e "${BLUE}=== CATEGORIES ===${NC}"
                    i=1
                    declare -a map_cats
                    while IFS= read -r cat; do
                        echo "$i. $cat"
                        map_cats[$i]="$cat"
                        ((i++))
                    done < categories.tmp
                    
                    echo "------------------------------------------------"
                    read -p "Select Category # (0 to back): " cat_idx
                    
                    if [[ "$cat_idx" == "0" || -z "$cat_idx" ]]; then
                        break
                    elif [[ -n "${map_cats[$cat_idx]}" ]]; then
                        selected_cat="${map_cats[$cat_idx]}"
                        
                        # Show feeds in category
                        grep -n "^$selected_cat|" feeds_db.txt > cat_feeds.tmp
                        
                        while true; do
                            clear
                            echo -e "${BLUE}Category: $selected_cat${NC}"
                            j=1
                            declare -a map_lines_cat
                            while IFS= read -r line; do
                                line_num=$(echo "$line" | cut -d: -f1)
                                content=$(echo "$line" | cut -d: -f2-)
                                feed_name=$(echo "$content" | cut -d'|' -f2)
                                
                                if grep -q "^$line_num$" selected_lines.txt; then
                                    mark="[x]"
                                    color=$GREEN
                                else
                                    mark="[ ]"
                                    color=$NC
                                fi
                                
                                printf "${color}%3d. %s %s${NC}\n" $j "$mark" "$feed_name"
                                map_lines_cat[$j]=$line_num
                                ((j++))
                            done < cat_feeds.tmp
                            
                            echo "------------------------------------------------"
                            read -p "Toggle # (0 to back, 'a' for all): " toggle_idx
                            
                            if [[ "$toggle_idx" == "0" ]]; then
                                break
                            elif [[ "$toggle_idx" == "a" ]]; then
                                # Select all in this category
                                while IFS= read -r line; do
                                    lnum=$(echo "$line" | cut -d: -f1)
                                    if ! grep -q "^$lnum$" selected_lines.txt; then
                                        echo "$lnum" >> selected_lines.txt
                                    fi
                                done < cat_feeds.tmp
                            elif [[ -n "${map_lines_cat[$toggle_idx]}" ]]; then
                                lnum=${map_lines_cat[$toggle_idx]}
                                if grep -q "^$lnum$" selected_lines.txt; then
                                    $SED_CMD "/^$lnum$/d" selected_lines.txt
                                else
                                    echo "$lnum" >> selected_lines.txt
                                fi
                            fi
                        done
                        rm cat_feeds.tmp
                    fi
                done
                rm categories.tmp
                ;;
            3)
                clear
                echo -e "${BLUE}=== SELECTED FEEDS ===${NC}"
                if [ -s selected_lines.txt ]; then
                    while IFS= read -r lnum; do
                        line=$(sed "${lnum}q;d" feeds_db.txt)
                        name=$(echo "$line" | cut -d'|' -f2)
                        cat=$(echo "$line" | cut -d'|' -f1)
                        echo "- $name ($cat)"
                    done < selected_lines.txt
                else
                    echo "No feeds selected."
                fi
                read -p "Press Enter to continue..."
                ;;
            4)
                break
                ;;
        esac
    done

    # Generate JSON
    json_content="["
    first=true
    count=0
    
    if [ -s selected_lines.txt ]; then
        while IFS= read -r lnum; do
            line=$(sed "${lnum}q;d" feeds_db.txt)
            url=$(echo "$line" | cut -d'|' -f3)
            
            if [ "$first" = true ]; then
                first=false
            else
                json_content+=","
            fi
            json_content+="\"$url\""
            ((count++))
        done < selected_lines.txt
    fi
    json_content+="]"

    if [ $count -gt 0 ]; then
        echo "$json_content" > feeds.json
        echo -e "${GREEN}${MSG_FEEDS_SAVED}${NC}"
    else
        echo -e "${RED}${MSG_FEEDS_NONE}${NC}"
        echo "[]" > feeds.json
    fi
    rm selected_lines.txt 2>/dev/null

    # OPML Import Step
    echo -e "\n${BLUE}--- OPML Import ---${NC}"
    read -p "${MSG_OPML_PROMPT}" opml_choice
    if [[ "$opml_choice" == "y" || "$opml_choice" == "Y" ]]; then
        read -p "${MSG_OPML_PATH}" opml_path
        if command -v python3 &> /dev/null; then
            python3 opml_manager.py import "$opml_path"
        else
            echo "Python3 not found, cannot import OPML."
        fi
    fi
fi

# 5. Setup and Start
echo -e "\n${BLUE}${MSG_STARTING}${NC}"

# Determine Docker Compose command
if docker compose version &> /dev/null; then
    DOCKER_COMPOSE_CMD="docker compose"
else
    DOCKER_COMPOSE_CMD="docker-compose"
fi

echo -e "${BLUE}${MSG_CLEANING}${NC}"
# Force remove any container with the same name to avoid conflicts
docker rm -f rss-telegram-bot 2>/dev/null

$DOCKER_COMPOSE_CMD down 2>/dev/null
$DOCKER_COMPOSE_CMD up -d --build

if [ $? -eq 0 ]; then
    echo -e "\n${BLUE}${MSG_DONE_HEADER}${NC}"
    echo -e "${GREEN}${MSG_DONE_SUCCESS}${NC}"
    echo -e "${MSG_LOGS} ${DOCKER_COMPOSE_CMD} logs -f"
    
    # Install CLI tool
    echo -e "\n${BLUE}Installing 'rsstelegram' CLI tool...${NC}"
    CLI_SCRIPT="$(pwd)/rsstelegram.sh"
    TARGET_LINK="/usr/local/bin/rsstelegram"
    
    if [ -f "$CLI_SCRIPT" ]; then
        ln -sf "$CLI_SCRIPT" "$TARGET_LINK"
        echo -e "${GREEN}Installed! You can now type 'rsstelegram' in any terminal to manage the bot.${NC}"
    else
        echo -e "${RED}Could not find rsstelegram.sh to install.${NC}"
    fi
else
    echo -e "\n${RED}${MSG_ERROR}${NC}"
    exit 1
fi